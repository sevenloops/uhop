# uhop/ai_gen.py
import os
import re
import ast
from pathlib import Path
from typing import Optional
import openai
from dotenv import load_dotenv
load_dotenv() 


DEFAULT_MODEL = "gpt-4o-mini"  # per your request

GENERATED_DIR = Path(__file__).resolve().parent / "generated_kernels"
os.makedirs(GENERATED_DIR, exist_ok=True)

def _extract_code_blocks(text: str) -> list:
    # regex to capture triple-backtick blocks with optional language
    blocks = re.findall(r"```(?:python)?\n(.*?)```", text, flags=re.DOTALL | re.IGNORECASE)
    if not blocks:
        # try a second pattern: fenced code without newline
        blocks = re.findall(r"```(.*?)```", text, flags=re.DOTALL)
    return [b.strip() for b in blocks if b.strip()]

def _verify_syntax(code: str) -> bool:
    try:
        ast.parse(code)
        return True
    except SyntaxError as e:
        return False

def generate_kernel(operation_name: str, prompt_extra: Optional[str]=None, model: str = DEFAULT_MODEL) -> Path:
    """
    Ask OpenAI to produce a Python file implementing a kernel for operation_name.
    The expected output should include a function named `generated_<operation_name>(a, b)` that returns result.
    """
    prompt = f"""
You are an expert systems developer. Produce a complete, single Python function called
`generated_{operation_name}(a, b)` that accepts two 2D numpy arrays and returns their matrix product as a numpy array.
It must be self-contained, use numpy, and be efficient for medium-sized matrices (e.g. 128-2048). Output only the code block between triple backticks and nothing else.
"""
    if prompt_extra:
        prompt += "\n\n" + prompt_extra

    # call OpenAI's ChatCompletion
    # WARNING: user must have OPENAI_API_KEY in env
    resp = openai.ChatCompletion.create(
        model=model,
        messages=[
            {"role":"system", "content": "You are an assistant that outputs runnable Python kernels."},
            {"role":"user", "content": prompt}
        ],
        max_tokens=1000,
        temperature=0.0
    )

    text = resp["choices"][0]["message"]["content"]
    blocks = _extract_code_blocks(text)
    if not blocks:
        # fallback: maybe the model returned plain code
        blocks = [text]

    # pick the longest block as likely the code
    code = max(blocks, key=len)

    # ensure imports exist
    if "import numpy" not in code and "numpy" not in code:
        code = "import numpy as np\n\n" + code

    # ensure function name
    expected_name = f"generated_{operation_name}"
    if expected_name not in code:
        # attempt to wrap code into a function
        code = f"import numpy as np\n\ndef {expected_name}(a, b):\n"
        for line in code.splitlines()[1:]:
            code += "    " + line + "\n"

    # verify syntax
    if not _verify_syntax(code):
        raise RuntimeError("AI-generated code failed syntax check.")

    # save file
    filename = GENERATED_DIR / f"gen_{operation_name}.py"
    with open(filename, "w") as f:
        f.write("# Auto-generated by UHOP ai_gen\n")
        f.write(code)
    return filename
